<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
    <title>Planetarium - Funilaria Digital</title>
	<meta name="description" content="Funilaria Digital - Web Tech Comms">
	<meta name="author" content="Rodrigo Achcar">
    <style>
        html, body, #content { width: 100%; height:100%; min-height:100%; overflow: hidden;}
        * {padding: 0; margin: 0;}
        .invisible{ opacity: 1; display: none; }
        h1, h2, p{ color: #ffffff; }
        canvas{ width: 100%; height: 100%; 	object-fit: contain; }
    </style>
</head>
<body>
    <div id="header">
        <div class="invisible"><h1>Digital Funnel - Graphical processing for best user experience</h1></div>
    </div>
	<div id="content">
	<canvas id="canvas"></canvas>
<div id="celestiaBodiesInfo" class="celestiaBodiesInfo" style="display: none">
    <div id="sun">
        <h2>Sol</h2>
        <p>Diâmetro: 1391000 km</p>
        <p>Rotação: 27 dias/terra</p>
    </div>
    <div id="mercury">
        <h2>Mercúrio</h2>
        <p>Distância Média do Sol: 57910000 km</p>
        <p>Diâmetro: 4880 km</p>
        <p>Rotação: 58 dias/terra</p>
        <p>Translação: 88 dias/terra</p>
    </div>
    <div id="venus">
        <h2>Vênus</h2>
        <p>Distância Média do Sol: 108200000 km</p>
        <p>Diâmetro: 12104 km</p>
        <p>Rotação: 243 dias/terra</p>
        <p>Translação: 225 dias/terra</p>
    </div>
    <div id="earth">
        <h2>Terra</h2>
        <p>Distância Média do Sol: 149600000 km</p>
        <p>Diâmetro: 12756 km</p>
        <p>Rotação: 1 dia/terra</p>
        <p>Translação: 365 dias/terra</p>
    </div>
    <div id="mars">
        <h2>Marte</h2>
        <p>Distância Média do Sol: 227940000 km</p>
        <p>Diâmetro: 6794 km</p>
        <p>Rotação: 1 dia/terra</p>
        <p>Translação: 687 dias/terra</p>
    </div>
    <div id="jupiter">
        <h2>Júpiter</h2>
        <p>Distância Média do Sol: 778330000 km</p>
        <p>Diâmetro: 142984 km</p>
        <p>Rotação: 0.41 dia/terra</p>
        <p>Translação: 4332 dias/terra</p>
    </div>
    <div id="saturn">
        <h2>Saturno</h2>
        <p>Distância Média do Sol: 1429400000 km</p>
        <p>Diâmetro: 120536 km</p>
        <p>Rotação: 0.41 dia/terra</p>
        <p>Translação: 10755 dias/terra</p>
    </div>
    <div id="uranus">
        <h2>Urano</h2>
        <p>Distância Média do Sol: 2870990000 km</p>
        <p>Diâmetro: 51118 km</p>
        <p>Rotação: 0.58 dia/terra</p>
        <p>Translação: 30687 dias/terra</p>
    </div>
    <div id="neptune">
        <h2>Netuno</h2>
        <p>Distância Média do Sol: 4504000000 km</p>
        <p>Diâmetro: 49532 km</p>
        <p>Rotação: 0.67 dia/terra</p>
        <p>Translação: 60190 dias/terra</p>
    </div>
	 <div id="pluto">
        <h2>Plutão</h2>
        <p>Distância Média do Sol: 4504000000 km</p>
        <p>Diâmetro: 49532 km</p>
        <p>Rotação: 0.67 dia/terra</p>
        <p>Translação: 60190 dias/terra</p>
    </div>
</div>

<script type="x-shader/x-vertex" id="vertexshader">
	varying vec2 vUv;
	void main() {
		vUv = uv;
		gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
	}
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
	uniform sampler2D baseTexture;
	uniform sampler2D bloomTexture;
	varying vec2 vUv;
	void main() {
		gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );
	}
</script>



<script type="importmap">
    {
		"imports": {
			"three": "/static/js/webgl/build/three.module.js",
			"three/addons/": "/static/js/webgl/jsm/"			
		}
	}
</script>
<script type="module">
import { Cache, Scene, WebGLRenderer, ACESFilmicToneMapping, PCFSoftShadowMap, PerspectiveCamera, Vector2, Vector3, Matrix4, Quaternion, Group, Raycaster, PointLight, Color, SRGBColorSpace, CustomBlending, AdditiveBlending, MaxEquation, CatmullRomCurve3, InstancedBufferGeometry, InstancedBufferAttribute, Float32BufferAttribute, CircleGeometry, PlaneGeometry, Mesh, MeshStandardMaterial, MeshBasicMaterial, MeshMatcapMaterial, LoadingManager, TextureLoader, Layers, ShaderMaterial, RawShaderMaterial, DoubleSide, Vector4, BufferAttribute } from 'three';

import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
import { Line2 } from 'three/addons/lines/Line2.js';
import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { Font } from 'three/addons/loaders/FontLoader.js';
import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';

Cache.enabled = true;
const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
const cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;

const scn = new Scene();
function init(){
	scn.files = filesLoad();
	scn.objsInfo = loadTexts();
	scn.meshesSpec = loadMeshesSpecs();
	scn.orbits = loadOrbits();
	loadFiles(scn.files);
}
async function loadFiles(filesObj){
	const manager = new LoadingManager();
	let filesLoadQtd = 0;
	let loadCount = 0;
	manager.onStart = function () {};
	manager.onProgress = function () {};
	manager.onLoad = function () {};
	manager.onError = function () {};
	for(let types of Object.entries(filesObj) ){
		for(let objs of Object.entries(types[1].files) ){
			for(let i = 0; i < objs[1].length; i++){
				filesLoadQtd++;
			}
		}
	}
	for(let types of Object.entries(filesObj) ){
		scn[types[0]] = {};
		for(let objs of Object.entries(types[1].files) ){
			scn[types[0]][objs[0]] = {};
			for(let i = 0; i < objs[1].length; i++){
				const data = await loadFile(types[1].loaderClass, `${types[1].absPath}${objs[0]}/${objs[1][i]}.${types[1].fileType}`);
				if(types[0] == 'textures'){
					data.colorSpace = SRGBColorSpace;
				}				
				scn[types[0]][objs[0]][objs[1][i]] = data;
				if( types[0] == 'fonts' ){
					scn[types[0]][objs[0]][objs[1][i]] = new Font( data );
				}
				loadCount++;
			}
		}
	}
	if(loadCount == filesLoadQtd){
		//console.log('loading complete');
		delete scn.files;
		setScn();
	}
}
function setScn(){
	scn.fps = 30;
	scn.currFrame = 0;
	scn.motionCount = 0;
	scn.canvas = document.getElementById("canvas");
	scn.canvas.width = window.innerWidth;
	scn.canvas.height = window.innerHeight;
	
	scn.pointer = new Vector2();
	scn.rCast = new Raycaster();
	scn.intersects = [];
	
	scn.selected = null;
	scn.worldUp = new Vector3(0, 1, 0);
	scn.worldScale = new Vector3(1, 1, 1);
	scn.frontPlaneDistance = 8;
	scn.renderGroup = [];
	scn.then = performance.now();
	scn.now = performance.now();
	
	scn.currIntrsc = null;
	scn.targetP = new Vector3();
	scn.targetQ = new Quaternion();
	scn.targetOffset = null;
	
	scn.renderer = setRenderer();
	setBloomPass();
	scn.add(setCamera() );
	scn.add( setLights() );
	
	setMeshes();
}
function setCamera(){
	let camera = new PerspectiveCamera( 35, scn.canvas.offsetWidth/ scn.canvas.offsetHeight, 0.01, 100000 );
	camera.name = 'cam';
	camera.scale.normalize();
	camera.view = new Vector2( 1, 1 );
	
	camera.frontPlaneRatio = camera.view.x / camera.view.y;
	camera.frameCue = 0;
	camera.lock = false;
	camera.info = false;
	camera.initP = new Vector3();
	camera.distance = null;
	camera.worldDirection = new Vector3();
	camera.getWorldDirection(camera.worldDirection); 
	camera.direction = new Vector3();
	camera.rMatrix = new Matrix4();
	camera.velocity = 0.0;
	camera.speed = 0.8;
	
	let frame = new Mesh(new PlaneGeometry(1, 1), new MeshBasicMaterial({color: 0x8888aa, transparent: true, opacity: 0.2, depthWrite: false}) );
	frame.name = 'frame';
	frame.geometry.computeBoundingBox();
	frame.scale.normalize();
	frame.position.z = -scn.frontPlaneDistance;
	camera.add(frame);
	frame.geometry.dispose();
	frame.material.dispose();
	
	camera.add(setHud( camera ));
	camera.add(setInfoCtnr());
	camera.position.set( 0, 2, (120+scn.frontPlaneDistance) );
	
	return camera;
}
function setMeshes(){
	let rayBodies = new Group();
	rayBodies.name = 'rayBodies';
	scn.add(rayBodies);
	let orbitPaths = new Group();
	orbitPaths.name = 'orbitPaths';
	scn.add(orbitPaths);
	for( let mesh of Object.entries(scn.models.planetarium['solar-system'].scene.children) ){
		let child = mesh[1];
		if(child.isMesh){
			let geometry = child.geometry;
			geometry.clearGroups();
			geometry.addGroup( 0, Infinity, 0 );
			let mainMesh = new Mesh();
			let materials = [];
			
			if(scn.orbits[child.name]){
				geometry = new InstancedBufferGeometry().copy(child.geometry);
				geometry.clearGroups();
				geometry.addGroup( 0, Infinity, 0 );
				geometry.instanceCount = 1;
				
				if(scn.meshesSpec[child.name].length > 1){
					geometry.clearGroups();
					for(let i = 0; i <= scn.meshesSpec[child.name].length; i++){
						geometry.addGroup( 0, Infinity, i );
					}
					geometry.instanceCount = scn.meshesSpec[child.name].length+1;
					for(let i = 1; i < scn.meshesSpec[child.name].length; i++){
						let mats = [];
						for(let j = 0; j < scn.meshesSpec[child.name][i].length; j++){
							let mat = new scn.meshesSpec[child.name][i][j].mat({ fog: false });
							for( let param of Object.entries(scn.meshesSpec[child.name][i][j].txt) ){
								mat[param[0]] = scn.textures[child.name][param[1]];
							}
							for( let param of Object.entries(scn.meshesSpec[child.name][i][j].spec) ){
								mat[param[0]] = param[1];
							}
							mat.name = scn.meshesSpec[child.name][i][j].txt.map;
							mat.needsUpdate = true;
							mats.push(mat);
						}
						let mesh = new Mesh(geometry, mats);
						mesh.name = scn.meshesSpec[child.name][i][0].txt.map;
						mesh.scale.normalize();
						mainMesh.add(mesh);
						
						if(mesh.name === 'earthClouds-map'){
							mesh.scale.setScalar(1.02);
						}
						for(let i = 0; i < mats.length; i++){
							mats[i].dispose();
						}
					}
				}
			}
			for(let i = 0; i < scn.meshesSpec[child.name][0].length; i++){
				let mat = new scn.meshesSpec[child.name][0][i].mat({ fog: false });
				for( let texture of Object.entries(scn.meshesSpec[child.name][0][i].txt) ){
					mat[texture[0]] = scn.textures[child.name][texture[1]];
				}
				for( let spec of Object.entries(scn.meshesSpec[child.name][0][i].spec) ){
					mat[spec[0]] = spec[1];
				}
				mat.name = scn.meshesSpec[child.name][0][i].txt.map;
				mat.needsUpdate = true;
				materials.push(mat);
			}
			mainMesh.geometry = geometry;
			mainMesh.scale.normalize();
			mainMesh.material = materials;
			mainMesh.castShadow  = true;
			mainMesh.receiveShadow = true;
			mainMesh.name = child.name;
			mainMesh.renderOrder = 2;
			scn.add(mainMesh);
			
			//if in scn.objsInfo it has raycast
			if(scn.objsInfo[child.name]){
				const raycastMat = new MeshBasicMaterial( { color: scn.orbits[child.name].color, transparent: true, opacity: 0, depthWrite : false } );
				let raycast = new Mesh(geometry, raycastMat);
				raycast.scale.normalize();
				raycast.scale.setScalar(0.6);
				raycast.name = child.name;
				raycast.renderOrder = 3;
				rayBodies.add(raycast);
				raycastMat.dispose();
			}
			
			geometry.dispose();
			for(let i = 0; i < materials.length; i++){
				for( let texture of Object.entries(scn.meshesSpec[child.name][0][i].txt) ){
					materials[i][texture[0]].dispose();
				}
				materials[i].dispose();
			}
			if(scn.orbits[child.name]){
				mainMesh.rotation.z = scn.orbits[child.name].axis;
			}
		}
		
		if(child.isLineSegments){
			let objToPathName = child.name.split('-orbit')[0];
			let pathPoints = child.geometry.attributes.position.array;
			let curveV3coords = [];							
			for(let i = 0; i < pathPoints.length; i+=3){
				curveV3coords.push(new Vector3(pathPoints[i], pathPoints[i+1], pathPoints[i+2] ));
			}
			let curve = new CatmullRomCurve3( curveV3coords );
			curve.curveType = 'centripetal';
			curve.closed = true;
			if(objToPathName !== 'sun'){
				const points = curve.getPoints( scn.orbits[objToPathName].subDivs );
				let geometry = new LineGeometry().setFromPoints( points );
				let matLine = new LineMaterial( {
					color: scn.orbits[objToPathName].color,
					linewidth: 4,
					dashed: true,
					dashScale : 0,
					transparent: true, opacity: 0.05, depthWrite : false
				} );
				let line = new Line2( geometry, matLine );
				line.computeLineDistances();
				line.scale.set( 1, 1, 1 );
				line.renderOrder = 0;
				line.name = objToPathName;
				orbitPaths.add( line );
				geometry.dispose();
				matLine.dispose();
			}
			scn.orbits[objToPathName]['curve'] = curve;
		}
	}
	getMesh(scn, 'saturn').add(getMesh(scn, 'saturnRing'))
	getMesh(scn, 'uranus').add(getMesh(scn, 'uranusRing'))
	getMesh(scn, 'galaxy').renderOrder = 0;
	for(let textures of Object.values(scn.textures) ){
		for(let texture of Object.values(textures) ){
			texture.dispose();
		}
	}
	scn.models.planetarium['solar-system'].scene.traverse(function(object){
		if( object.isMesh ){
			object.geometry.dispose();
			object.material.dispose();
		}
		if(object.isLineSegments){
			object.geometry.dispose();
		}
	});
	delete scn.textures;
	delete scn.models;
	delete scn.meshesSpec;
	getMesh(scn, 'sun').layers.enable( 1 );
	run();
}
function run(cam = getMesh(scn, 'cam')){
	scn.renderer.domElement.addEventListener( 'pointermove', pointermove);
	scn.renderer.domElement.addEventListener( 'pointerdown', pointerdown );
	window.addEventListener( 'pointerup', pointerup );
/*	
	scn.renderer.domElement.addEventListener( 'touchstart', touchstart);
	scn.renderer.domElement.addEventListener( 'touchmove', touchmove);
	window.addEventListener( 'touchend', touchend);
*/	
	document.addEventListener( 'wheel', wheel );
	document.addEventListener( 'keyup', keyup );
	document.addEventListener( 'keydown', keydown );
	window.addEventListener( 'resize', resize );
	resize();
	animate();
}
function resize() {
	let cam = getMesh(scn, 'cam');
	scn.renderer.setSize( scn.canvas.parentElement.clientWidth, scn.canvas.parentElement.clientHeight  );
	cam.aspect = scn.canvas.offsetWidth/ scn.canvas.offsetHeight;
	cam.fov = Math.round(((scn.canvas.offsetWidth*scn.canvas.offsetHeight) / scn.canvas.offsetWidth)/18);
	cam.updateProjectionMatrix();
	cam.view = calcViewSize( scn.frontPlaneDistance, cam.view ) ;
	cam.frontPlaneRatio = cam.view.x / cam.view.y;
	
	getMesh(cam, 'hud').bb.width = cam.view.x;
	getMesh(cam, 'hud').bb.height = (cam.view.y/cam.view.x);
	getMesh(cam, 'hud').bb.y = (-getMesh(scn, 'cam').view.y/2) + getMesh(cam, 'hud').bb.height/2;
	getMesh(cam, 'hud').position.z = -scn.frontPlaneDistance;
	getMesh(cam, 'frame').scale.set( getMesh(cam, 'hud').bb.width, getMesh(cam, 'hud').bb.height, 0 );
	getMesh(cam, 'frame').position.y = getMesh(cam, 'hud').bb.y;

	for( let i = 0; i < getMesh(cam, 'hud').children.length; i++ ){
		let btn = getMesh(cam, 'hud').children[i];
		let x = (btn.bb.width * btn.layout.x);
		let y = getMesh(cam, 'hud').bb.y;
		let scale = getMesh(cam, 'hud').bb.height * btn.layout.scale;
		btn.position.set(x, y, 0);
		btn.scale.set(scale, scale, 1);
		btn.startV.set(x, y, 0);
		console.log(btn)
	}
	getMesh(cam, 'infoCtnr').scale.setScalar( cam.frontPlaneRatio );
	getMesh(cam, 'infoCtnr').position.y = -getMesh(cam, 'hud').bb.y;
	cam.hudPercent = -((((cam.view.y/2)-getMesh(cam, 'frame').scale.y)*100)/(cam.view.y/2))/100;
}

//[ geometry[{material{txt,spec}}] ] 
function loadMeshesSpecs(){
	return {
		earth : [
		[ { mat: MeshStandardMaterial, txt:{map: 'earthDay-map', bumpMap: 'earthDay-bumpMap', metalnessMap: 'earthDay-metalnessMap'}, spec: {roughness: 1, metalness: 1, anisotropy: 0.2,  bumpScale: 0.001, transparent: true, depthWrite : false, 
		blending: CustomBlending, 
		blendEquation: MaxEquation,
		}} , { mat: MeshStandardMaterial, txt:{map: 'earthNight-map', lightMap: 
		'earthNight-map', bumpMap: 'earthDay-bumpMap'}, spec: {roughness: 1, metalness: 0, lightMapIntensity: 8, bumpScale: 0.001
		}} ],
		[{ mat: MeshStandardMaterial, txt:{map: 'earthClouds-map', alphaMap: 'earthClouds-map', displacementMap: 'earthClouds-map'}, spec: {displacementScale: 0.08, roughness: 1, metalness: 0, transparent: true, depthWrite : false, opacity: 0.6 }} ]
		],
		galaxy: [[ 
		{ mat: MeshBasicMaterial, txt:{map:'galaxy-map', lightMap:'galaxy-map'}, spec: {lightMapIntensity: 2.0}}
		]],
		sun: [[ { mat: MeshStandardMaterial, txt:{map:'sun-map', lightMap: 'sun-map', emissiveMap: 'sun-map', bumpMap: 'sun-bumpMap'}, spec: {roughness: 0, metalness: 0, lightMapIntensity: 8, emissive: new Color(0.7, 0.4, 0), emissiveIntensity: 2, bumpScale: 1} } ]],

		mercury: [[ { mat: MeshStandardMaterial, txt:{map:'mercury-map', bumpMap: 'mercury-bumpMap'}, spec: {roughness: 0, metalness: 0, bumpScale: 0.02} } ]],
		
		venus: [[ { mat: MeshStandardMaterial, txt:{map:'venus-map', bumpMap: 'venus-bumpMap'}, spec: {roughness: 0.1, metalness: 0, bumpScale: 0.02} } ]],
		
		mars: [[ { mat: MeshStandardMaterial, txt:{map:'mars-map', bumpMap: 'mars-bumpMap'}, spec: {roughness: 1, metalness: 0, bumpScale: 0.02} } ]],
		
		jupiter: [[ { mat: MeshStandardMaterial, txt:{map:'jupiter-map'}, spec: {roughness: 0, metalness: 0} } ]],
		
		saturn: [[ { mat: MeshStandardMaterial, txt:{map:'saturn-map'}, spec: {roughness: 0, metalness: 0} } ]],
		
		saturnRing: [[ { mat: MeshStandardMaterial, txt:{map:'saturnRing-map', lightMap: 'saturnRing-map',alphaMap: 'saturnRing-alphaMap'}, spec: {roughness: 0.4, metalness: 0.4, lightMapIntensity: 3, transparent: true, depthWrite : false, blending: AdditiveBlending} } ]],
		
		uranus: [[ { mat: MeshStandardMaterial, txt:{map:'uranus-map'}, spec: {roughness: 0, metalness: 0} } ]],
		
		uranusRing: [[ { mat: MeshStandardMaterial, txt:{map:'uranusRing-map', lightMap: 'uranusRing-map',alphaMap: 'uranusRing-alphaMap'}, spec: {roughness: 0.4, metalness: 0.4, lightMapIntensity: 3, transparent: true, depthWrite : false, blending: AdditiveBlending} } ]],
		
		neptune: [[ { mat: MeshStandardMaterial, txt:{map:'neptune-map'}, spec: {roughness: 0, metalness: 0} } ]],
		
		pluto: [[ { mat: MeshStandardMaterial, txt:{map:'pluto-map', bumpMap: 'pluto-bumpMap'}, spec: {roughness: 0, metalness: 0, bumpScale: 0.02} } ]]
	}
}
function loadOrbits(){
	return {
	sun: {translation: 29.78, rotation: 0.0006875, axis: 0, color: 0xd84b10, subDivs: 20},
	mercury: {translation: 47.87, rotation: 0.0083, axis: Math.PI/180 * -0.1, color: 0x5e2902, subDivs: 40},
	venus: {translation: 35.02, rotation: 0.00652, axis: Math.PI/180 * -177, color: 0x803710, subDivs: 60},
	earth: {translation: 29.78, rotation: 0.01574, axis: Math.PI/180 * 23, color: 0x14425b, subDivs: 100},
	mars: {translation: 24.077, rotation: 0.00866, axis: Math.PI/180 * -25, color: 0x81524b, subDivs: 140},
	jupiter: {translation:13.07, rotation: 0.0045583, axis: Math.PI/180 * -3, color: 0xae6137, subDivs: 180},
	saturn: {translation: 9.69, rotation: 0.0036840, axis: Math.PI/180 * -27, color: 0xd9b383, subDivs: 220},
	uranus: {translation: 6.81, rotation: 0.0014794, axis: Math.PI/180 * -98, color: 0x9fb6c3, subDivs: 260},
	neptune: {translation: 5.43, rotation: 0.009719, axis: Math.PI/180 * -30, color: 0x5a69b6, subDivs: 320},
	pluto: {translation: 5.43, rotation: 0.009719, axis: Math.PI/180 * -30, color: 0x535c6b, subDivs: 360}
	}
}

function calcViewSize(depth, target){
	return getMesh(scn, 'cam').getViewSize(depth, target );
}
function easeLinear(t, b, c, d) {
	return c * t / d + b;
}	
function easeInOutQuad(t, b, c, d) {
	if ((t /= d / 2) < 1) return c / 2 * t * t + b;
	return -c / 2 * ((--t) * (t - 2) - 1) + b;
}
function generateText(textContent, fontStyle, fontSize){
	let geometry = new TextGeometry( textContent, {
		font: fontStyle,
		size: fontSize,
		height: 0.0,
		depth: 0.0,
		curveSegments: 1.4,
		bevelEnabled: false,
		bevelThickness: 0,
		bevelSize: 0,
	} );
	geometry.clearGroups();
	geometry.computeBoundingBox();
	let textMat = new MeshMatcapMaterial( { color: 0xffffff, transparent: true, fog: false } );
	let textMesh = new Mesh( geometry, textMat );
	textMesh.material.opacity = 0;
	let width = Math.trunc( Math.abs(textMesh.geometry.boundingBox.min.x - textMesh.geometry.boundingBox.max.x) *1000)/1000 ;
	let height = Math.trunc( Math.abs(textMesh.geometry.boundingBox.min.y - textMesh.geometry.boundingBox.max.y) *1000)/1000 ;
	textMesh.geometry.translate(-width/2, -height, 0);
	textMesh.bb = {w:width, h:height};
	geometry.dispose();
	textMat.dispose();
	textMesh.scale.normalize();
	return textMesh;	
}
function loadFile(loaderClass, filePath) {
	return new Promise((resolve) => {
		const loader = new loaderClass;
		loader.load(filePath, (data) => {
			resolve(data);
		});
	});
}
function getMesh( parent, name ){
	return parent.children[ parent.children.findIndex(item => item.name === name) ];
}
function clamp(val, min, max) {
    return Math.trunc( (val > max ? max : val < min ? min : val) * 10000) / 10000;
}
function animeItem(item, property, paramArr, endVArr, duration, delay=0, endAction=null, ease=easeInOutQuad){
	duration = Math.trunc(((duration + delay)* 1000)/scn.fps);
	for (let i = 0; i < paramArr.length; i++){
		let startV = item[property][paramArr[i]];
		let deltaV = endVArr[i] - startV;
		if(i > 0){endAction = null}
		scn.renderGroup.push( [ scn.currFrame, duration, item, property, [paramArr[i]], ease, startV, deltaV, endVArr[i], endAction ] );
	}
	return;
}

function setRenderer(){
	let renderer = new WebGLRenderer( { canvas: scn.canvas, antialias: true, alpha: false, precision: "highp", premultipliedAlpha: false } );
	renderer.setSize( scn.canvas.offsetWidth, scn.canvas.offsetHeight );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.toneMapping = ACESFilmicToneMapping;
	renderer.shadowMap.enable = true;
	renderer.shadowMap.type = PCFSoftShadowMap;
	renderer.physicallyCorrectLights = true;	
	renderer.sortObjects = false;				
	return renderer;
}
function setBloomPass(){
	let BLOOM_SCENE = 1;
	scn.bloomLayer = new Layers();
	scn.bloomLayer.set( BLOOM_SCENE );
	scn.renderScene = new RenderPass( scn, getMesh(scn, 'cam') );
	scn.bloomPass = new UnrealBloomPass( new Vector2( scn.canvas.width, scn.canvas.width ), 1.5, 0.4, 0.85 );
	scn.bloomPass.threshold = 0.1;
	scn.bloomPass.strength = 0.1;
	scn.bloomPass.radius = 0.01;
	scn.bloomComposer = new EffectComposer( scn.renderer );
	scn.bloomComposer.renderToScreen = false;
	scn.bloomComposer.addPass( scn.renderScene );
	scn.bloomComposer.addPass( scn.bloomPass );
	scn.mixPass = new ShaderPass(
		new ShaderMaterial( {
			uniforms: {
				baseTexture: { value: null },
				bloomTexture: { value: scn.bloomComposer.renderTarget2.texture }
			},
			vertexShader: document.getElementById( 'vertexshader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
			defines: {}
		} ), 'baseTexture'
	);
	scn.mixPass.needsSwap = true;
	scn.outputPass = new OutputPass();
	scn.finalComposer = new EffectComposer( scn.renderer );
	scn.finalComposer.addPass( scn.renderScene );
	scn.finalComposer.addPass( scn.mixPass );
	scn.finalComposer.addPass( scn.outputPass );
}

function setLights(){
	let sunLight = new PointLight( 0xffffff, 100000);
	sunLight.name = 'sunLight';
	sunLight.power = 500000;
	sunLight.castShadow = true;
	sunLight.shadow.mapSize.width = 512; // default
	sunLight.shadow.mapSize.height = 512; // default
	sunLight.shadow.camera.near = 0.5; // default
	sunLight.shadow.camera.far = 5000; // default				
	sunLight.position.set( 0, 0, 0 );
	sunLight.needsUpdate = true;
	return sunLight;
}
function setInfoCtnr(){
	let infoCtnr = new Group();
	infoCtnr.name = 'infoCtnr';
	infoCtnr.h2 = { style: scn.fonts.rubik['Rubik-Bold'], size: 0.5 };
	infoCtnr.p = { style: scn.fonts.rubik['Rubik-Regular'], size: 0.24 };
	infoCtnr.position.z = -scn.frontPlaneDistance;
	infoCtnr.renderOrder = 4;
	return infoCtnr;
}

function setHud( cam ){
	let hud = new Group();
	hud.name ='hud';
	hud.bb = {};

	hud.renderOrder = 4;
	hud.toggle = false;
	hud.pressed = [];
	
	hud.objs = loadHudObjs();
	for( let ctrls of Object.values(hud.objs) ){
		ctrls.builder(hud, ctrls);
	}
	
	delete hud.objs;
	return hud;
}
function setStick(hud, ctrls){
	let buffer = new CircleGeometry(ctrls.size, ctrls.subDivs);
	buffer.computeBoundingSphere();
	const geometry = new InstancedBufferGeometry().copy( buffer );
	geometry.instanceCount = ctrls.meshes.length;
	//let translations = new Float32Array([-0.2, 0, 0, 0.5, 0, 0]);
	//let scales = new Float32Array([0.2, 0.2, 0.2, 0.4, 0.4, 0.4]);
	//geometry.setAttribute( 'translation', new InstancedBufferAttribute( translations, 3, 1 ) );
    //geometry.setAttribute( 'scale', new InstancedBufferAttribute( scales, 3, 1 ) );
	const material = new MeshMatcapMaterial( {color: 0xbbbbbb, transparent: true, depthWrite: false, opacity: 0.4 } );
	const mesh = new Mesh( geometry, material );

	for(let i = 0; i < ctrls.meshes.length; i++){
		geometry.addGroup( 0, Infinity, i );
		let mat = new ctrls.meshes[i].mat(ctrls.meshes[i].spec);
		let mesh = new Mesh(geometry, mat);
		mesh.scale.normalize();
		mesh.geometry.computeBoundingSphere();
		mesh.geometry.computeBoundingBox();
		mesh.bb = {};
		mesh.bb.width = mesh.geometry.boundingSphere.radius*2;
		mesh.bb.height = mesh.geometry.boundingSphere.radius*2;
		mesh.name = ctrls.meshes[i].attr.name;
		mesh.layout = ctrls.meshes[i].layout;
		mesh.identifier = ctrls.meshes[i].attr.identifier;
		mesh.action = ctrls.meshes[i].attr.action;
		mesh.startV = ctrls.meshes[i].attr.startV;
		mesh.weight = ctrls.meshes[i].attr.weight;
		hud.add(mesh);
		mat.dispose();
	}
	buffer.dispose();
	return;
}
function loadHudObjs(){
	return {
		stick: {
			builder: setStick, geometry: CircleGeometry, size:0.5, subDivs:64, meshes: 
			[
				{ mat: MeshMatcapMaterial, spec: {color: 0xbbbbbb, transparent: true, depthWrite: false, opacity: 0.4 }, layout: {x:-1, y:0, scale: 0.5}, attr: { name: 'stickT', identifier: null, action: {x:'translateX', y:'translateZ'}, startV: new Vector2(), weight: { x:(0.2), y:(0.3) } } },
				{ mat: MeshMatcapMaterial, spec: {color: 0xbbbbbb, transparent: true, depthWrite: false, opacity: 0.4 }, layout: {x:1, y:0, scale: 0.5}, attr: { name: 'stickR', identifier: null, action: { x:'rotateY', y:'rotateX' }, startV: new Vector2(), weight: { x:(0.2), y:(0.3) } } }
			]
		}
	}
}

function pointerdown( e ) {
	e.preventDefault();
	intersectClickEvent(e);
}
function touchstart( e ) {
	e.preventDefault();
	intersectClickEvent(e);
}
function intersectClickEvent(e, cam=getMesh(scn, 'cam')){
	e.preventDefault();
	if ( e.changedTouches ) {
		if ( e.changedTouches.length > 1 ) { return }
			e = e.changedTouches[0];
	}
	scn.pointer.x = ( e.clientX / scn.canvas.offsetWidth ) * 2 - 1;
	scn.pointer.y = - ( e.clientY / scn.canvas.offsetHeight ) * 2 + 1;
	if( scn.pointer.y > cam.hudPercent ){
		scn.rCast.setFromCamera( scn.pointer, getMesh(scn, 'cam') );
		scn.intersects = scn.rCast.intersectObjects( getMesh(scn, 'rayBodies').children, false );
		if(!getMesh(scn, 'cam').lock && !getMesh(scn, 'cam').info){
			if ( scn.intersects.length > 0 ) {
				scn.currIntrsc = scn.intersects[0].object.name;
				cam.lock = true;
				lockTarget();
			}
		}
		if ( scn.intersects.length == 0 ) {
			getMesh(scn, 'cam').lock = false;
			if( getMesh(scn, 'cam').info ){
				 hideInfo();
			}
		}
	}
	if( scn.pointer.y <= cam.hudPercent ){
		scn.rCast.setFromCamera( scn.pointer, getMesh(scn, 'cam') );
		scn.intersects = scn.rCast.intersectObjects( getMesh(getMesh(scn, 'cam'), 'hud').children, false );
		if ( scn.intersects.length > 0 ) {
			console.log(scn.intersects[0].object.startV.x, scn.pointer.x )
			getMesh(cam, 'hud').toggle = true;
			getMesh(cam, 'hud').selected = scn.intersects[0].object;
			getMesh(cam, 'hud').selected.identifier = e.identifier;
			//getMesh(cam, 'hud').selected.startV.copy(scn.pointer);
			getMesh(cam, 'hud').pressed.push(getMesh(cam, 'hud').selected);
		}
	}
}
function pointermove( e ){
	e.preventDefault();
	intersectMoveEvent(e);
}
function touchmove( e ) {
	e.preventDefault();
	intersectMoveEvent(e);
}
function intersectMoveEvent(e, cam=getMesh(scn, 'cam')){
	e.preventDefault();
	if ( e.changedTouches ) {
		if ( e.changedTouches.length > 1 ) { return }
		e = e.changedTouches[0];
	}
	scn.pointer.x = ( e.clientX / scn.canvas.offsetWidth ) * 2 - 1;
	scn.pointer.y = - ( e.clientY / scn.canvas.offsetHeight ) * 2 + 1;

	if( scn.pointer.y > cam.hudPercent ){
		scn.rCast.setFromCamera( scn.pointer, getMesh(scn, 'cam') );
		scn.intersects = scn.rCast.intersectObjects( getMesh(scn, 'rayBodies').children, false );
		
		if(!getMesh(scn, 'cam').lock && !getMesh(scn, 'cam').info){
			/*
			getMesh(scn, 'cam').rotateX( scn.pointer.y * Math.PI/180 );
			getMesh(scn, 'cam').rotateY(scn.pointer.x * -Math.PI/180);
			*/
			if ( scn.intersects.length > 0 ) {
				if(scn.currIntrsc == null){
					//'new'			
					scn.currIntrsc = scn.intersects[0].object.name;
					animeItem(getMesh(getMesh(scn, 'rayBodies'), scn.currIntrsc), 'material', ['opacity'], [0.3], 0.5);
				}
				if(scn.currIntrsc != scn.intersects[0].object.name){
					//'changed'
					animeItem(getMesh(getMesh(scn, 'rayBodies'), scn.currIntrsc), 'material', ['opacity'], [0], 0.5);
					scn.currIntrsc = scn.intersects[0].object.name;	
					animeItem(getMesh(getMesh(scn, 'rayBodies'), scn.currIntrsc), 'material', ['opacity'], [0.3], 0.5);
				}
			}
			if ( scn.intersects.length === 0 &&  scn.currIntrsc != null) {
				//'none'
				animeItem(getMesh(getMesh(scn, 'rayBodies'), scn.currIntrsc), 'material', ['opacity'], [0], 0.5);
				scn.currIntrsc = null;
			}
		}
	}
	if( scn.pointer.y <= cam.hudPercent ){	
		if(getMesh(cam, 'hud').toggle === true){
			getMesh(scn, 'cam').velocity += (getMesh(scn, 'cam').speed - getMesh(scn, 'cam').velocity) * 0.3;
			for(let i = 0; i<getMesh(cam, 'hud').pressed.length; i++){
				let vX = clamp( -1, ((scn.pointer.x - getMesh(cam, 'hud').selected.startV.x)), 2 );
				let vY = clamp( -1, (scn.pointer.y - getMesh(cam, 'hud').selected.startV.y), 1 );
				getMesh(cam, 'hud').selected.position.x = vX;
				getMesh(cam, 'hud').selected.position.y = vY;
				getMesh(scn, 'cam')[getMesh(cam, 'hud').selected.action.x](vX);
				getMesh(scn, 'cam')[getMesh(cam, 'hud').selected.action.y](vY);
			}
		}
	}
}
function pointerup( e, cam=getMesh(scn, 'cam') ){
	e.preventDefault();
	if(getMesh(cam, 'hud').toggle === true){
		getMesh(cam, 'hud').selected.position.x = scn.intersects[0].object.startV.x;
		getMesh(cam, 'hud').selected.position.y = scn.intersects[0].object.startV.y;
		getMesh(cam, 'hud').toggle = false;
	}
}
function touchend( e ) {
	e.preventDefault();
	if(scn.hud.toggle === true){
		scn.hud.selected.position.x = 0;
		scn.hud.selected.position.y = 0;
		scn.hud.toggle = false;
	}
}
function keydown( e ) {
	if(!getMesh(scn, 'cam').lock && !getMesh(scn, 'cam').info){
		getMesh(scn, 'cam').velocity += (getMesh(scn, 'cam').speed - getMesh(scn, 'cam').velocity) * .3;
		if (e.key === 'ArrowUp') {
			getMesh(scn, 'cam').translateZ(-getMesh(scn, 'cam').velocity);
		}
		if (e.key === 'ArrowDown') {
			getMesh(scn, 'cam').translateZ(getMesh(scn, 'cam').velocity);
		}
		if (e.key === 'ArrowRight') {
			getMesh(scn, 'cam').translateX(getMesh(scn, 'cam').velocity);
		}
		if (e.key === 'ArrowLeft') {
			getMesh(scn, 'cam').translateX(-getMesh(scn, 'cam').velocity);
		}
	}
}
function keyup( e ) {
	getMesh(scn, 'cam').velocity = 0;
}
function wheel(e){
	if(!getMesh(scn, 'cam').lock){
		getMesh(scn, 'cam').velocity += (getMesh(scn, 'cam').speed - getMesh(scn, 'cam').velocity) * .002;
		getMesh(scn, 'cam').translateZ(getMesh(scn, 'cam').velocity * e.deltaY );
	}
	return;
}

function lockTarget( cam=getMesh(scn, 'cam') ){
	cam.frameCue = 0;
	scn.selected = scn.currIntrsc;
	scn.targetOffset = ( getMesh(getMesh(scn, 'rayBodies'), scn.currIntrsc).geometry.boundingSphere.radius * 3) + scn.frontPlaneDistance;
}
function cameraLock( cam=getMesh(scn, 'cam') ){
	cam.initP = cam.position;
	scn.targetP = getMesh(getMesh(scn, 'rayBodies'), scn.currIntrsc).getWorldPosition( scn.targetP );
	cam.distance = cam.initP.distanceTo(scn.targetP);
	cam.speed = cam.distance/10;
	if( cam.distance > scn.targetOffset ){
		cam.velocity += (cam.speed - cam.velocity) * .3;
		cam.translateZ(-cam.velocity);
		
		cam.rMatrix.lookAt( cam.position, scn.targetP, scn.worldUp );
		scn.targetQ.setFromRotationMatrix( cam.rMatrix );
		if ( ! cam.quaternion.equals( scn.targetQ ) ) {
		const step = (cam.quaternion.angleTo(scn.targetQ) ) * (cam.frameCue/30);
			cam.quaternion.rotateTowards( scn.targetQ, step );
		}
		cam.frameCue++;
	}
	if( cam.distance <= scn.targetOffset ){
		animeItem(getMesh(getMesh(scn, 'rayBodies'), scn.currIntrsc), 'material', ['opacity'], [0], 0.5);
		cam.lookAt(scn.targetP);
		cam.lock = false;
		cam.info = true;
		displayInfo();
	}
}
function displayInfo( cam=getMesh(scn, 'cam') ){
	cam.frameCue = 0;
	let textFieldPY = 0;
	for(let i=0; i< scn.objsInfo[scn.currIntrsc].length; i++){
		let textField = scn.objsInfo[scn.currIntrsc][i];
		let textMesh = generateText(textField.text, getMesh(cam, 'infoCtnr')[textField.tag].style, getMesh(cam, 'infoCtnr')[textField.tag].size);
		getMesh(cam, 'infoCtnr').add( textMesh );
		textMesh.position.y = textFieldPY;
		textFieldPY -= textMesh.bb.h;
	}
	for(let i=0; i< getMesh(cam, 'infoCtnr').children.length; i++){
		animeItem(getMesh(cam, 'infoCtnr').children[i], 'material', ['opacity'], [1], 1);
	}
}
function cameraInfo( cam=getMesh(scn, 'cam') ){
	scn.targetP = getMesh(getMesh(scn, 'rayBodies'), scn.currIntrsc).getWorldPosition( scn.targetP );
	cam.lookAt(scn.targetP);
}
function hideInfo( cam=getMesh(scn, 'cam') ){
	for(let i=0; i< getMesh(cam, 'infoCtnr').children.length; i++){
		animeItem(getMesh(cam, 'infoCtnr').children[i], 'material', ['opacity'], [0], 1, 0, function(){
			if(i == getMesh(cam, 'infoCtnr').children.length-1){
				clearInfoCtnr();
			}
		});
	}
}
function clearInfoCtnr( cam=getMesh(scn, 'cam') ) {
    for(let i=0; i< getMesh(cam, 'infoCtnr').children.length; i++){
		getMesh(cam, 'infoCtnr').children[i].geometry.dispose();
		getMesh(cam, 'infoCtnr').children[i].material.dispose();
	}
	getMesh(cam, 'infoCtnr').clear();
	cam.info = false;
	scn.selected = null;
	scn.currIntrsc = null;
}

function filesLoad(){
	return {
		textures: {
			loaderClass: TextureLoader, absPath : "/media/planetarium/", fileType: 'avif',
			files: {
				galaxy: ['galaxy-map' ],
				sun: [ 'sun-map', 'sun-bumpMap' ],
				mercury: [ 'mercury-map', 'mercury-bumpMap' ],
				venus: [ 'venus-map', 'venus-bumpMap'],
				earth : [ 'earthDay-map', 'earthDay-bumpMap', 'earthDay-metalnessMap', 'earthNight-map', 'earthClouds-map' ],
				

				mars: [ 'mars-map', 'mars-bumpMap' ],
				jupiter: ['jupiter-map' ],
				saturn: [ 'saturn-map' ],
				saturnRing: [ 'saturnRing-map', 'saturnRing-alphaMap' ],
				uranus: [ 'uranus-map' ],
				uranusRing: [ 'uranusRing-map', 'uranusRing-alphaMap' ],
				neptune: [ 'neptune-map' ],
				pluto: [ 'pluto-map', 'pluto-bumpMap' ]
			}
		},
		models: {
			loaderClass: GLTFLoader, absPath : "/static/js/webgl/models/", fileType: 'glb',
			files: {
				planetarium: ['solar-system']
			}
		},
		fonts: {
			loaderClass: TTFLoader, absPath : "/static/fonts/", fileType: 'ttf',
			files: {
				rubik: [ 'Rubik-Regular', 'Rubik-Bold']
			}
		}
	}
}
function loadTexts(){
	let textsInfo = document.getElementById('celestiaBodiesInfo');
	let obj = {};
	for(let i=0; i < textsInfo.children.length; i++)
	{
		let id = textsInfo.children[i].id;
		obj[id] = [];
		for(let j=0; j < textsInfo.children[i].children.length; j++){
			let elm = textsInfo.children[i].children[j];
			let textField = {};
			textField.tag = elm.tagName.toLowerCase();
			textField.text = elm.textContent;
			obj[id].push(textField);
		}
	}
	return obj;
}

function animate() {
	if( scn.now - scn.then >= scn.fps){
		scn.then = performance.now();
		render();
	}
	scn.now = performance.now();
	requestAnimationFrame(animate);
}
function render(){
	scn.currFrame++;
	for( let key of Object.entries(scn.orbits) ){
		getMesh(scn, key[0]).position.copy(key[1].curve.getPointAt( (scn.currFrame/key[1].subDivs * key[1].translation / 10) % key[1].subDivs/key[1].subDivs ) );
		getMesh(scn, key[0]).rotation.y += key[1].rotation;
		
		getMesh(getMesh(scn, 'rayBodies'), key[0]).position.copy(key[1].curve.getPointAt( (scn.currFrame/key[1].subDivs * key[1].translation / 10) % key[1].subDivs/key[1].subDivs ) );
	}
	getMesh(scn, 'earth').children[0].rotation.y += 0.003;
	if(getMesh(scn, 'cam').lock){ cameraLock(); }
	if(getMesh(scn, 'cam').info){ cameraInfo(); }
	for(let i = 0; i < scn.renderGroup.length; i++){
		// [ startFrame, duration(seconds), item, property, param, ease, startV, deltaV, endV, endAction ]
		scn.motionCount = scn.currFrame - scn.renderGroup[i][0];
		if(scn.motionCount >= scn.renderGroup[i][1]){
			scn.renderGroup[i][2][scn.renderGroup[i][3] ][scn.renderGroup[i][4] ] = scn.renderGroup[i][8];
			if(scn.renderGroup[i][9]){
				scn.renderGroup[i][9]();
			}
			scn.renderGroup.splice(i, 1);
			continue;
		}
		scn.renderGroup[i][2][scn.renderGroup[i][3] ][scn.renderGroup[i][4] ] = Math.trunc(scn.renderGroup[i][5](scn.motionCount, scn.renderGroup[i][6], scn.renderGroup[i][7], scn.renderGroup[i][1])*100 )/100;			
	}
	getMesh(scn, 'cam').updateProjectionMatrix();
	scn.renderer.render( scn, getMesh(scn, 'cam') );
	//scn.bloomComposer.render();
	//scn.finalComposer.render();
	

}





init();
</script>
</div>
</body></html>
