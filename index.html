
<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
    <title>Planetarium - Funilaria Digital</title>
	<meta name="description" content="Funilaria Digital - Web Tech Comms">
	<meta name="author" content="Rodrigo Achcar">
    <link rel="stylesheet" href="static/css/pages/planetarium/base.css">	
    <style>
        html, body { width: 100%; height:100%; min-height:100%; overflow: hidden; }
        * {padding: 0; margin: 0;}
        .invisible{
            opacity: 1; display: none;
        }
        h1, h2, p{
            color: #FFFFFF;
        }
    </style>
	<link rel="stylesheet" href="static/css/pages/planetarium/home.css">
    <link rel="stylesheet" href="static/css/pages/planetarium/main.css">
</head>
<body>
    <div class="invisible"><h1>Digital Funnel - Graphical processing for a best user experience</h1></div>
	<canvas id="canvas"></canvas>
<div id="celestiaBodiesInfo" class="celestiaBodiesInfo" style="display: none">
    <div id="sun">
        <h2>Sol</h2>
        <p>Diâmetro: 1391000 km</p>
        <p>Rotação: 27 dias/terra</p>
    </div>
    <div id="mercury">
        <h2>Mercúrio</h2>
        <p>Distância Média do Sol: 57910000 km</p>
        <p>Diâmetro: 4880 km</p>
        <p>Rotação: 58 dias/terra</p>
        <p>Translação: 88 dias/terra</p>
    </div>
    <div id="venus">
        <h2>Vênus</h2>
        <p>Distância Média do Sol: 108200000 km</p>
        <p>Diâmetro: 12104 km</p>
        <p>Rotação: 243 dias/terra</p>
        <p>Translação: 225 dias/terra</p>
    </div>
    <div id="earth">
        <h2>Terra</h2>
        <p>Distância Média do Sol: 149600000 km</p>
        <p>Diâmetro: 12756 km</p>
        <p>Rotação: 1 dia/terra</p>
        <p>Translação: 365 dias/terra</p>
    </div>
    <div id="mars">
        <h2>Marte</h2>
        <p>Distância Média do Sol: 227940000 km</p>
        <p>Diâmetro: 6794 km</p>
        <p>Rotação: 1 dia/terra</p>
        <p>Translação: 687 dias/terra</p>
    </div>
    <div id="jupiter">
        <h2>Júpiter</h2>
        <p>Distância Média do Sol: 778330000 km</p>
        <p>Diâmetro: 142984 km</p>
        <p>Rotação: 0.41 dia/terra</p>
        <p>Translação: 4332 dias/terra</p>
    </div>
    <div id="saturn">
        <h2>Saturno</h2>
        <p>Distância Média do Sol: 1429400000 km</p>
        <p>Diâmetro: 120536 km</p>
        <p>Rotação: 0.41 dia/terra</p>
        <p>Translação: 10755 dias/terra</p>
    </div>
    <div id="uranus">
        <h2>Urano</h2>
        <p>Distância Média do Sol: 2870990000 km</p>
        <p>Diâmetro: 51118 km</p>
        <p>Rotação: 0.58 dia/terra</p>
        <p>Translação: 30687 dias/terra</p>
    </div>
    <div id="neptune">
        <h2>Netuno</h2>
        <p>Distância Média do Sol: 4504000000 km</p>
        <p>Diâmetro: 49532 km</p>
        <p>Rotação: 0.67 dia/terra</p>
        <p>Translação: 60190 dias/terra</p>
    </div>
	 <div id="pluto">
        <h2>Plutão</h2>
        <p>Distância Média do Sol: 4504000000 km</p>
        <p>Diâmetro: 49532 km</p>
        <p>Rotação: 0.67 dia/terra</p>
        <p>Translação: 60190 dias/terra</p>
    </div>
</div>
<script type="importmap">
    {
		"imports": {
			"three": "/static/js/webgl/build/three.module.js",
			"three/addons/": "/static/js/webgl/jsm/"			
		}
	}
</script>
<script type="module">
import { Cache, Scene, WebGLRenderer, ACESFilmicToneMapping, PCFSoftShadowMap, PerspectiveCamera, Vector2, Vector3, Matrix4, Quaternion, Group, Raycaster, PointLight, Color, SRGBColorSpace, CustomBlending, AdditiveBlending, MaxEquation, CatmullRomCurve3, InstancedBufferGeometry, Mesh, MeshStandardMaterial, MeshBasicMaterial, MeshMatcapMaterial, LoadingManager, TextureLoader } from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
import { Line2 } from 'three/addons/lines/Line2.js';
import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { Font } from 'three/addons/loaders/FontLoader.js';
import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';

Cache.enabled = true;
const requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
const cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;

let scn = new Scene();
function init(){
	scn.files = filesLoad();
	scn.objsInfo = loadTexts();
	scn.meshesSpec = loadMeshesSpecs();
	scn.orbits = loadOrbits();
	scn.objsIntrsc = [];
	scn.rCastMeshPaths = {};
	loadFiles(scn.files);
}
function pointermove( event ){
	event.preventDefault();
	scn.pointer.x = ( event.clientX / scn.canvas.width ) * 2 - 1;
	scn.pointer.y = - ( event.clientY / scn.canvas.height ) * 2 + 1;
	scn.rCast.setFromCamera( scn.pointer, scn.cam );
	scn.intersects = scn.rCast.intersectObjects( scn.objsIntrsc, false );
	if(!scn.cam.lock){
		scn.cam.rotateX(scn.pointer.y * Math.PI/180);
		scn.cam.rotateY(scn.pointer.x * -Math.PI/180);
	}
	if ( scn.intersects.length > 0 ) {	
		if(scn.currIntrsc == null){
			//'new'			
			scn.currIntrsc = scn.intersects[0];
			animeItem(scn.currIntrsc.object, 'material', ['opacity'], [0.3], 0.5);
		}
		if(scn.currIntrsc.object.name != scn.intersects[0].object.name){
			//'changed'
			animeItem(scn.currIntrsc.object, 'material', ['opacity'], [0], 0.5);
			scn.currIntrsc = scn.intersects[0];	
			animeItem(scn.currIntrsc.object, 'material', ['opacity'], [0.3], 0.5);
		}
	}
	if ( scn.intersects.length == 0 ) {
		if(scn.currIntrsc != null){
			//'none'
			animeItem(scn.currIntrsc.object, 'material', ['opacity'], [0], 0.5);
			scn.currIntrsc = null;
		}
	}
}
function pointerdown( event ) {
	event.preventDefault();
	scn.pointer.x = ( event.clientX / scn.canvas.width ) * 2 - 1;
	scn.pointer.y = - ( event.clientY / scn.canvas.height ) * 2 + 1;
	scn.rCast.setFromCamera( scn.pointer, scn.cam );
	scn.intersects = scn.rCast.intersectObjects( scn.objsIntrsc, false );
	if ( scn.intersects.length > 0 ) {
		lockTarget();
	}
	if ( scn.intersects.length == 0 ) {
		scn.cam.lock = false;
		scn.selected = null;
		if( scn.cam.info ){
			 hideInfo();
		}
	}
}
function lockTarget(){
	scn.currIntrsc = scn.intersects[0];
	scn.cam.frameCue = 0;
	scn.cam.target = scn.currIntrsc.object;
	scn.selected = scn.cam.target.name;
	scn.cam.targetOffset = scn.cam.target.geometry.boundingSphere.radius * 2;
	scn.cam.lock = true;
}
function cameraLock(){
	scn.cam.initP = scn.cam.position;
	scn.cam.targetP = scn.cam.target.getWorldPosition( scn.cam.targetP );
	scn.cam.distance = scn.cam.initP.distanceTo(scn.cam.targetP);

	if( scn.cam.distance > scn.cam.targetOffset ){
		scn.cam.getWorldDirection(scn.cam.worldDirection);
		scn.cam.position.addScaledVector(scn.cam.worldDirection, scn.cam.speed);
		
		scn.cam.rMatrix.lookAt( scn.cam.position, scn.cam.targetP, scn.worldUp );
		scn.cam.targetQ.setFromRotationMatrix( scn.cam.rMatrix );
		if ( ! scn.cam.quaternion.equals( scn.cam.targetQ ) ) {
		const step = (scn.cam.quaternion.angleTo(scn.cam.targetQ) ) * (scn.cam.frameCue/30);
			scn.cam.quaternion.rotateTowards( scn.cam.targetQ, step );
		}
		scn.cam.frameCue++;
	}
	if( scn.cam.distance <= scn.cam.targetOffset ){
		scn.cam.lookAt(scn.cam.targetP);
		scn.cam.lock = false;
		scn.cam.info = true;
		displayInfo();
	}
}
function displayInfo(){
	scn.cam.frameCue = 0;
	let textFieldPY = 0;
	for(let i=0; i< scn.objsInfo[scn.cam.target.name].length; i++){
		let textField = scn.objsInfo[scn.cam.target.name][i];
		let textMesh = generateText(textField.text, scn.cam.infoCtnr[textField.tag].style, scn.cam.infoCtnr[textField.tag].size);
		scn.cam.infoCtnr.add( textMesh );
		textMesh.position.y = textFieldPY;
		textFieldPY -= textMesh.bb.h;
	}
	for(let i=0; i< scn.cam.infoCtnr.children.length; i++){
		animeItem(scn.cam.infoCtnr.children[i], 'material', ['opacity'], [1], 1);
	}
}
function cameraInfo(){
	scn.cam.targetP = scn.cam.target.getWorldPosition( scn.cam.targetP );
	scn.cam.lookAt(scn.cam.targetP);
}
function hideInfo(){
	for(let i=0; i< scn.cam.infoCtnr.children.length; i++){
		animeItem(scn.cam.infoCtnr.children[i], 'material', ['opacity'], [0], 1, 0, function(){
			if(i == scn.cam.infoCtnr.children.length-1){
				clearInforCtnr();
			}
		});
	}
}
function clearInforCtnr() {
    for(let i=0; i< scn.cam.infoCtnr.children.length; i++){
		scn.cam.infoCtnr.children[i].geometry.dispose();
		scn.cam.infoCtnr.children[i].material.dispose();
	}
	scn.cam.infoCtnr.clear();
	scn.cam.info = false;
	scn.selected = null;
}
function pointerup( event ){}
function keydown( event ) {
	if(!scn.cam.lock){
		scn.cam.getWorldDirection(scn.cam.worldDirection);
		if (event.key === 'ArrowUp') {
			scn.cam.position.addScaledVector(scn.cam.worldDirection, scn.cam.speed);
		}
		if (event.key === 'ArrowDown') {
			scn.cam.position.addScaledVector(scn.cam.worldDirection.negate(), scn.cam.speed);
		}
		if (event.key === 'ArrowRight') {
			scn.cam.direction.crossVectors(scn.cam.worldDirection, scn.worldUp).normalize();
			scn.cam.position.addScaledVector(scn.cam.direction, scn.cam.speed);
		}
		if (event.key === 'ArrowLeft') {
			scn.cam.direction.crossVectors(scn.cam.worldDirection, scn.worldUp).normalize();
			scn.cam.position.addScaledVector(scn.cam.direction.negate(), scn.cam.speed);
		}
		scn.cam.lock = false;
		scn.cam.info = false;
	}
}
function keyup( event ) {
}
function wheel(event){
	if(!scn.cam.lock){
		scn.cam.getWorldDirection(scn.cam.worldDirection);
		event.distance = Math.trunc((event.deltaY/16)*100)/100;
		if(event.deltaY >= 0){
			scn.cam.position.addScaledVector(scn.cam.worldDirection.negate(), scn.cam.speed);
		}
		if(event.deltaY < 0){
			scn.cam.position.addScaledVector(scn.cam.worldDirection, scn.cam.speed);
		}
	}
	return;
}
function resize(camera, renderer) {
	scn.canvas.width = window.innerWidth;
	scn.canvas.height = window.innerHeight;
	scn.renderer.setSize( scn.canvas.width, scn.canvas.height );
	scn.cam.aspect = scn.canvas.clientWidth / scn.canvas.clientHeight;
	scn.cam.updateProjectionMatrix();

}
function clamp(val, min, max) {
    return Math.trunc( (val > max ? max : val < min ? min : val) * 100) / 100;
}
function animate() {
	if( scn.now - scn.then >= scn.fps){
		scn.then = performance.now();
		render();
	}
	scn.now = performance.now();
	requestAnimationFrame(animate);
}
function render(){
	scn.currFrame++;
	for( let key of Object.entries(scn.orbits) ){
		scn.meshes[key[0]].position.copy(key[1].curve.getPointAt( (scn.currFrame/key[1].subDivs * key[1].translation / 10) % key[1].subDivs/key[1].subDivs ) );
		scn.meshes[key[0]].rotation.y += key[1].rotation;
	}
	scn.meshes['earth'].children[0].rotation.y += 0.003;
	if(scn.cam.lock){ cameraLock(); }
	if(scn.cam.info){ cameraInfo(); }
	for(let i = 0; i < scn.renderGroup.length; i++){
		// [ startFrame, duration(seconds), item, property, param, ease, startV, deltaV, endV, endAction ]
		scn.motionCount = scn.currFrame - scn.renderGroup[i][0];
		if(scn.motionCount >= scn.renderGroup[i][1]){
			scn.renderGroup[i][2][scn.renderGroup[i][3] ][scn.renderGroup[i][4] ] = scn.renderGroup[i][8];
			if(scn.renderGroup[i][9]){
				scn.renderGroup[i][9]();
			}
			scn.renderGroup.splice(i, 1);
			continue;
		}
		scn.renderGroup[i][2][scn.renderGroup[i][3] ][scn.renderGroup[i][4] ] = Math.trunc(scn.renderGroup[i][5](scn.motionCount, scn.renderGroup[i][6], scn.renderGroup[i][7], scn.renderGroup[i][1])*100 )/100;			
	}
	scn.cam.updateProjectionMatrix();
	scn.renderer.render( scn, scn.cam );
}
function animeItem(item, property, paramArr, endVArr, duration, delay=0, endAction=null, ease=easeInOutQuad){
	duration = Math.trunc(((duration + delay)* 1000)/scn.fps);
	for (let i = 0; i < paramArr.length; i++){
		let startV = item[property][paramArr[i]];
		let deltaV = endVArr[i] - startV;
		if(i > 0){endAction = null}
		scn.renderGroup.push( [ scn.currFrame, duration, item, property, [paramArr[i]], ease, startV, deltaV, endVArr[i], endAction ] );
	}
	return;
}
function setMeshes(){
	scn.meshes = {};
	for( let mesh of Object.entries(scn.models.planetarium['solar-system'].scene.children) ){
		let child = mesh[1];
		if(child.isMesh){
			let geometry = child.geometry;
			geometry.clearGroups();
			geometry.addGroup( 0, Infinity, 0 );
			let mainMesh = new Mesh();
			let materials = [];
			
			//if in scn.orbits it has raycast
			if(scn.orbits[child.name]){
				geometry = new InstancedBufferGeometry().copy(child.geometry);
				geometry.clearGroups();
				geometry.addGroup( 0, Infinity, 0 );
				geometry.instanceCount = 1;
				
				if(scn.meshesSpec[child.name].length > 1){
					geometry.clearGroups();
					for(let i = 0; i <= scn.meshesSpec[child.name].length; i++){
						geometry.addGroup( 0, Infinity, i );
					}
					geometry.instanceCount = scn.meshesSpec[child.name].length+1;
					for(let i = 1; i < scn.meshesSpec[child.name].length; i++){
						let mats = [];
						for(let j = 0; j < scn.meshesSpec[child.name][i].length; j++){
							let mat = new scn.meshesSpec[child.name][i][j].mat({ fog: false });
							for( let param of Object.entries(scn.meshesSpec[child.name][i][j].txt) ){
								mat[param[0]] = scn.textures[child.name][param[1]];
							}
							for( let param of Object.entries(scn.meshesSpec[child.name][i][j].spec) ){
								mat[param[0]] = param[1];
							}
							mat.name = scn.meshesSpec[child.name][i][j].txt.map;
							mat.needsUpdate = true;
							mats.push(mat);
						}
						let mesh = new Mesh(geometry, mats);
						mesh.name = scn.meshesSpec[child.name][i][0].txt.map;
						mainMesh.add(mesh);
						
						if(mesh.name === 'earthClouds-map'){
							mesh.scale.setScalar(1.008);
						}
						for(let i = 0; i < mats.length; i++){
							mats[i].dispose();
						}
					}
				}
				const raycastMat = new MeshBasicMaterial( { color: scn.orbits[child.name].color, transparent: true, opacity: 0, depthWrite : false } );
				let raycast = new Mesh(geometry, raycastMat);
				raycast.scale.setScalar(1.04);
				raycast.name = child.name;
				raycast.renderOrder = 2;
				scn.objsIntrsc.push(raycast);
				scn.rCastMeshPaths[child.name] = raycast;
				mainMesh.add(raycast);
				raycastMat.dispose();
			}
			
			for(let i = 0; i < scn.meshesSpec[child.name][0].length; i++){
				let mat = new scn.meshesSpec[child.name][0][i].mat({ fog: false });
				for( let texture of Object.entries(scn.meshesSpec[child.name][0][i].txt) ){
					mat[texture[0]] = scn.textures[child.name][texture[1]];
				}
				for( let spec of Object.entries(scn.meshesSpec[child.name][0][i].spec) ){
					mat[spec[0]] = spec[1];
				}
				mat.name = scn.meshesSpec[child.name][0][i].txt.map;
				mat.needsUpdate = true;
				materials.push(mat);
			}
			
			mainMesh.geometry = geometry;
			mainMesh.scale.normalize();
			mainMesh.material = materials;
			mainMesh.castShadow  = true;
			mainMesh.receiveShadow = true;
			mainMesh.name = child.name;
			mainMesh.renderOrder = 2;
			scn.add(mainMesh);
			scn.meshes[child.name] = mainMesh;
			geometry.dispose();
			for(let i = 0; i < materials.length; i++){
				for( let texture of Object.entries(scn.meshesSpec[child.name][0][i].txt) ){
					materials[i][texture[0]].dispose();
				}
				materials[i].dispose();
			}
			if(scn.orbits[child.name]){
				mainMesh.rotation.z = scn.orbits[child.name].axis;
			}
		}
		if(child.isLineSegments){
			let objToPathName = child.name.split('-orbit')[0];
			let pathPoints = child.geometry.attributes.position.array;
			let curveV3coords = [];							
			for(let i = 0; i < pathPoints.length; i+=3){
				curveV3coords.push(new Vector3(pathPoints[i], pathPoints[i+1], pathPoints[i+2] ));
			}
			let curve = new CatmullRomCurve3( curveV3coords );
			curve.curveType = 'centripetal';
			curve.closed = true;
			if(objToPathName !== 'sun'){
				const points = curve.getPoints( scn.orbits[objToPathName].subDivs );
				let geometry = new LineGeometry().setFromPoints( points );
				let matLine = new LineMaterial( {
					color: scn.orbits[objToPathName].color,
					linewidth: 4,
					dashed: true,
					dashScale : 0,
					transparent: true, opacity: 0.16, depthWrite : false
				} );
				
				let line = new Line2( geometry, matLine );
				line.computeLineDistances();
				line.scale.set( 1, 1, 1 );
				line.renderOrder = 0;
				scn.add( line );
				geometry.dispose();
				matLine.dispose();
			}
			scn.orbits[objToPathName]['curve'] = curve;
			scn.orbits[objToPathName]['object'] = scn.meshes[objToPathName];
			scn.orbits[objToPathName]['raycast'] = scn.rCastMeshPaths[objToPathName];
			
		}
	}
	scn.meshes['saturn'].add(scn.meshes['saturnRing']);
	scn.meshes['uranus'].add(scn.meshes['uranusRing']);
	scn.meshes['galaxy'].renderOrder = 0;
	for(let textures of Object.values(scn.textures) ){
		for(let texture of Object.values(textures) ){
			texture.dispose();
		}
	}
	scn.models.planetarium['solar-system'].scene.traverse(function(object){
		if( object.isMesh ){
			object.geometry.dispose();
		}
	});
	delete scn.textures;
	delete scn.models;
	delete scn.meshesSpec;
	setScn();
}
function setScn(){
	scn.fps = 60;
	scn.currFrame = 0;
	scn.motionCount = 0;
	scn.canvas = document.getElementById("canvas");
	scn.canvas.bb = scn.canvas.getBoundingClientRect();
	scn.canvas.width = Math.trunc(scn.canvas.bb.width*100)/100;
	scn.canvas.height = Math.trunc(scn.canvas.bb.height*100)/100;
	
	scn.pointer = new Vector2();
	scn.rCast = new Raycaster();
	scn.intersects = null;
	scn.currIntrsc = null;
	scn.selected = null;
	scn.worldUp = new Vector3(0, 1, 0);

	scn.renderGroup = [];
	scn.renderer = setRenderer();
	scn.cam = setCamera();
	scn.add(scn.cam);
	scn.sunLight = setLights();
	scn.add( scn.sunLight );
	scn.cam.infoCtnr = setInfoCtnr();
	scn.cam.add(scn.cam.infoCtnr);
	scn.cam.position.set( -60, 2, 60 );

	document.addEventListener( 'pointermove', pointermove);
	document.addEventListener( 'pointerdown', pointerdown );
	document.addEventListener( 'pointerup', pointerup );
	document.addEventListener( 'wheel', wheel );
	document.addEventListener( 'keyup', keyup );
	document.addEventListener( 'keydown', keydown );
	window.addEventListener( 'resize', resize );
	scn.then = performance.now();
	scn.now = performance.now();
	animate();
}
function setRenderer(){
	let renderer = new WebGLRenderer( { canvas: scn.canvas, antialias: true, alpha: false, precision: "highp", premultipliedAlpha: false } );
	renderer.setSize( scn.canvas.width, scn.canvas.height );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.toneMapping = ACESFilmicToneMapping;
	renderer.shadowMap.enable = true;
	renderer.shadowMap.type = PCFSoftShadowMap;
	renderer.physicallyCorrectLights = true;	
	renderer.sortObjects = false;				
	return renderer;
}
function setCamera(){
	let camera = new PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.01, 100000 );
	camera.aspect = scn.canvas.width /scn.canvas.height;
	camera.frameCue = 0;
	camera.lock = false;
	camera.info = false;
	camera.initP = new Vector3();
	camera.distance = null;
	camera.target = null;
	camera.targetP = new Vector3();
	camera.targetQ = new Quaternion();
	camera.targetOffset = null;
	camera.worldDirection = new Vector3();
	camera.getWorldDirection(camera.worldDirection); 
	camera.direction = new Vector3();
	camera.rMatrix = new Matrix4();
	camera.speed = 1.0;
	return camera;
}
function setInfoCtnr(){
	let infoCtnr = new Group();
	infoCtnr.position.z = -0.4;
	infoCtnr.h2 = { style: scn.fonts.rubik['Rubik-Bold'], size: 0.02 };
	infoCtnr.p = { style: scn.fonts.rubik['Rubik-Regular'], size: 0.01 };
	
	return infoCtnr;
}

function setLights(){
	let sunLight = new PointLight( 0xffffff, 100000);
	sunLight.power = 500000;
	sunLight.castShadow = true;
	sunLight.shadow.mapSize.width = 512; // default
	sunLight.shadow.mapSize.height = 512; // default
	sunLight.shadow.camera.near = 0.5; // default
	sunLight.shadow.camera.far = 5000; // default				
	sunLight.position.set( 0, 0, 0 );
	sunLight.needsUpdate = true;
	return sunLight;
}
async function loadFiles(filesObj){
	const manager = new LoadingManager();
	let filesLoadQtd = 0;
	let loadCount = 0;
	manager.onStart = function () {};
	manager.onProgress = function () {};
	manager.onLoad = function () {};
	manager.onError = function () {};
	for(let types of Object.entries(filesObj) ){
		for(let objs of Object.entries(types[1].files) ){
			for(let i = 0; i < objs[1].length; i++){
				filesLoadQtd++;
			}
		}
	}
	for(let types of Object.entries(filesObj) ){
		scn[types[0]] = {};
		for(let objs of Object.entries(types[1].files) ){
			scn[types[0]][objs[0]] = {};
			for(let i = 0; i < objs[1].length; i++){
				const data = await loadFile(types[1].loaderClass, `${types[1].absPath}${objs[0]}/${objs[1][i]}.${types[1].fileType}`);
				if(types[0] == 'textures'){
					data.colorSpace = SRGBColorSpace;
				}				
				scn[types[0]][objs[0]][objs[1][i]] = data;
				if( types[0] == 'fonts' ){
					scn[types[0]][objs[0]][objs[1][i]] = new Font( data );
				}
				loadCount++;
			}
		}
	}
	if(loadCount == filesLoadQtd){
		//console.log('loading complete');
		delete scn.files;
		setMeshes();
	}
}
function loadFile(loaderClass, filePath) {
	return new Promise((resolve) => {
		const loader = new loaderClass;
		loader.load(filePath, (data) => {
			resolve(data);
		});
	});
}
function filesLoad(){
	return {
		textures: {
			loaderClass: TextureLoader, absPath : '/media/planetarium/', fileType: 'webp',
			files: {
				galaxy: ['nx-map', 'ny-map', 'nz-map', 'px-map', 'py-map', 'pz-map' ],
				sun: [ 'sun-map', 'sun-bumpMap' ],
				mercury: [ 'mercury-map', 'mercury-bumpMap' ],
				venus: [ 'venus-map', 'venus-bumpMap'],
				
				
				earth : [ 'earthDay-map', 'earthDay-bumpMap', 'earthDay-metalnessMap', 'earthNight-map', 'earthClouds-map' ],
				

				mars: [ 'mars-map', 'mars-bumpMap' ],
				jupiter: ['jupiter-map' ],
				saturn: [ 'saturn-map' ],
				saturnRing: [ 'saturnRing-map', 'saturnRing-alphaMap' ],
				uranus: [ 'uranus-map' ],
				uranusRing: [ 'uranusRing-map', 'uranusRing-alphaMap' ],
				neptune: [ 'neptune-map' ],
				pluto: [ 'pluto-map', 'pluto-bumpMap' ]
			}
		},
		models: {
			loaderClass: GLTFLoader, absPath : "/static/js/webgl/models/", fileType: 'glb',
			files: {
				planetarium: ['solar-system']
			}
		},
		fonts: {
			loaderClass: TTFLoader, absPath : "/static/fonts/", fileType: 'ttf',
			files: {
				rubik: [ 'Rubik-Regular', 'Rubik-Bold']
			}
		}
	}
}

//[ geometry[{material{txt,spec}}] ] 
function loadMeshesSpecs(){
	return {
		earth : [
		[ { mat: MeshStandardMaterial, txt:{map: 'earthDay-map', bumpMap: 'earthDay-bumpMap', metalnessMap: 'earthDay-metalnessMap'}, spec: {roughness: 0, metalness: 0, anisotropy: 0.1,  bumpScale: 0.008, transparent: true, depthWrite : false, 
		blending: CustomBlending, 
		blendEquation: MaxEquation,
		}} , { mat: MeshStandardMaterial, txt:{map: 'earthNight-map', lightMap: 
		'earthNight-map', bumpMap: 'earthDay-bumpMap'}, spec: {roughness: 0, metalness: 0, lightMapIntensity: 12, bumpScale: 0.008
		}} ],

		[{ mat: MeshStandardMaterial, txt:{map: 'earthClouds-map', alphaMap: 'earthClouds-map', displacementMap: 'earthClouds-map'}, spec: {displacementScale: 0.04, roughness: 0, metalness: 0, transparent: true, depthWrite : false, opacity: 0.6 }} ]
		],
		
		galaxy: [[ 
		{ mat: MeshBasicMaterial, txt:{map:'px-map'}, spec: {specular: 0.2}}, 
		{ mat: MeshBasicMaterial, txt: {map:'nx-map'}, spec: {specular: 0.2} }, 
		{ mat: MeshBasicMaterial, txt:{map:'py-map'}, spec: {specular: 0.2 }}, 
		{ mat: MeshBasicMaterial, txt:{map:'ny-map'}, spec: { specular: 0.2 }}, 
		{ mat: MeshBasicMaterial, txt:{map:'pz-map'}, spec: {specular: 0.2}}, 
		{ mat: MeshBasicMaterial, txt:{map:'nz-map'}, spec: {specular: 0.2} } 
		]],
		
		sun: [[ { mat: MeshStandardMaterial, txt:{map:'sun-map', lightMap: 'sun-map', emissiveMap: 'sun-map', bumpMap: 'sun-bumpMap'}, spec: {roughness: 0, metalness: 0, lightMapIntensity: 8, emissive: new Color(0.7, 0.4, 0), emissiveIntensity: 2, bumpScale: 1} } ]],
		
		mercury: [[ { mat: MeshStandardMaterial, txt:{map:'mercury-map', bumpMap: 'mercury-bumpMap'}, spec: {roughness: 0, metalness: 0, bumpScale: 0.02} } ]],
		
		venus: [[ { mat: MeshStandardMaterial, txt:{map:'venus-map', bumpMap: 'venus-bumpMap'}, spec: {roughness: 0, metalness: 0, bumpScale: 0.02} } ]],
		
		mars: [[ { mat: MeshStandardMaterial, txt:{map:'mars-map', bumpMap: 'mars-bumpMap'}, spec: {roughness: 1, metalness: 0, bumpScale: 0.02} } ]],
		
		jupiter: [[ { mat: MeshStandardMaterial, txt:{map:'jupiter-map'}, spec: {roughness: 0, metalness: 0} } ]],
		
		saturn: [[ { mat: MeshStandardMaterial, txt:{map:'saturn-map'}, spec: {roughness: 0, metalness: 0} } ]],
		
		saturnRing: [[ { mat: MeshStandardMaterial, txt:{map:'saturnRing-map', lightMap: 'saturnRing-map',alphaMap: 'saturnRing-alphaMap'}, spec: {roughness: 0.4, metalness: 0.4, lightMapIntensity: 3, transparent: true, depthWrite : false, blending: AdditiveBlending} } ]],
		
		uranus: [[ { mat: MeshStandardMaterial, txt:{map:'uranus-map'}, spec: {roughness: 0, metalness: 0} } ]],
		
		uranusRing: [[ { mat: MeshStandardMaterial, txt:{map:'uranusRing-map', lightMap: 'uranusRing-map',alphaMap: 'uranusRing-alphaMap'}, spec: {roughness: 0.4, metalness: 0.4, lightMapIntensity: 3, transparent: true, depthWrite : false, blending: AdditiveBlending} } ]],
		
		neptune: [[ { mat: MeshStandardMaterial, txt:{map:'neptune-map'}, spec: {roughness: 0, metalness: 0} } ]],
		
		pluto: [[ { mat: MeshStandardMaterial, txt:{map:'pluto-map', bumpMap: 'pluto-bumpMap'}, spec: {roughness: 0, metalness: 0, bumpScale: 0.02} } ]]
	}
}

function loadOrbits(){
	return {
	sun: {translation: 29.78, rotation: 0.0006875, axis: 0, color: 0xd84b10, subDivs: 20},
	mercury: {translation: 47.87, rotation: 0.0083, axis: Math.PI/180 * -0.1, color: 0x5e2902, subDivs: 40},
	venus: {translation: 35.02, rotation: 0.00652, axis: Math.PI/180 * -177, color: 0x803710, subDivs: 60},
	earth: {translation: 29.78, rotation: 0.01574, axis: Math.PI/180 * 23, color: 0x14425b, subDivs: 100},
	mars: {translation: 24.077, rotation: 0.00866, axis: Math.PI/180 * -25, color: 0x81524b, subDivs: 140},
	jupiter: {translation:13.07, rotation: 0.0045583, axis: Math.PI/180 * -3, color: 0xae6137, subDivs: 180},
	saturn: {translation: 9.69, rotation: 0.0036840, axis: Math.PI/180 * -27, color: 0xd9b383, subDivs: 220},
	uranus: {translation: 6.81, rotation: 0.0014794, axis: Math.PI/180 * -98, color: 0x9fb6c3, subDivs: 260},
	neptune: {translation: 5.43, rotation: 0.009719, axis: Math.PI/180 * -30, color: 0x5a69b6, subDivs: 320},
	pluto: {translation: 5.43, rotation: 0.009719, axis: Math.PI/180 * -30, color: 0x535c6b, subDivs: 360}
	}
}
function loadTexts(){
	let textsInfo = document.getElementById('celestiaBodiesInfo');
	let obj = {};
	for(let i=0; i < textsInfo.children.length; i++)
	{
		let id = textsInfo.children[i].id;
		obj[id] = [];
		for(let j=0; j < textsInfo.children[i].children.length; j++){
			let elm = textsInfo.children[i].children[j];
			let textField = {};
			textField.tag = elm.tagName.toLowerCase();
			textField.text = elm.textContent;
			obj[id].push(textField);
		}
	}
	return obj;
}
function easeLinear(t, b, c, d) {
	return c * t / d + b;
}	
function easeInOutQuad(t, b, c, d) {
	if ((t /= d / 2) < 1) return c / 2 * t * t + b;
	return -c / 2 * ((--t) * (t - 2) - 1) + b;
}
function generateText(textContent, fontStyle, fontSize){
	let geometry = new TextGeometry( textContent, {
		font: fontStyle,
		size: fontSize,
		height: 0.0,
		depth: 0.0,
		curveSegments: 1.6,
		bevelEnabled: false,
		bevelThickness: 0,
		bevelSize: 0,
	} );
	geometry.clearGroups();
	geometry.computeBoundingBox();
	geometry.computeVertexNormals();
	let textMat = new MeshMatcapMaterial( { color: 0xffffff, transparent: true, fog: false } );
	let textMesh = new Mesh( geometry, textMat );
	textMesh.material.opacity = 0;
	textMesh.scale.normalize();
	let width = Math.trunc( Math.abs(textMesh.geometry.boundingBox.min.x - textMesh.geometry.boundingBox.max.x) *100)/100 ;
	let height = Math.trunc( Math.abs(textMesh.geometry.boundingBox.min.y - textMesh.geometry.boundingBox.max.y) *100)/100 ;
	textMesh.geometry.translate(-width/2, -height, 0);
	textMesh.bb = {w:width, h:height};
	geometry.dispose();
	textMat.dispose();
	return textMesh;	
}
init();
</script>
</div>
<div></div></body></html>
